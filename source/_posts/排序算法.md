---
title: 排序算法
date: 2018-07-12 20:01:11
tags: [排序算法]
categories: ["其他"]
cover_img: https://ws4.sinaimg.cn/large/006tNbRwly1fxzf7vu9bdj31hc0u0k4q.jpg
---

# 排序算法

## 冒泡排序（O(n^2)）

从第一个开始俩俩比较，大的放到后边，一轮之后，最大的数字就冒泡到了最后边。
然后开始第二轮比较。。。。。直到所有数字排序完成

代码实现

```javascript
function bubleSort(arr) {
  for (let i = 0; i < arr.length - 1 /*轮数*/; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
}
```

<!--more-->

## 选择排序（O(n^2)）

假设第一个是最小的，依次和其他的比较，如果比第一个小，就交换位置。。。。。
最终就按照从大到小的顺序排好了
代码实现

```javascript
function sectionSort(arr) {
  for (let i = 0; i < arr.length - 1 /*轮数*/; i++) {
    let min = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[min] > arr[j]) {
        min = j;
      }
    }
    [arr[i], arr[min]] = [arr[min], arr[i]];
  }
}
```

## 插入排序（O(n^2)）

假设第一个元素排好了，从第二个元素开始，和已排序元素比较，放到排序好的合适的位置

代码实现

```javascript
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (arr[i] < arr[j]) {
        arr.splice(j, 0, arr[i]);
        arr.splice(i + 1, 1);
        break;
      }
    }
  }
}
```

## 快速排序

已第一个为基准，分成俩部分，左边比基数小，右边比基数大，最后把这三部分连接起来
左边和右边再分别进行快排

写起来简便，但不太好的写法

```javascript
function quickSort() {
  if (arr.length <= 1) {
    return arr;
  }
  let arrLeft = [];
  let arrRight = [];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] >= arr[0]) {
      arrRight.push(arr[i]);
    } else {
      arrLeft.push(arr[i]);
    }
  }
  return quickSort(arrLeft)
    .concat(arr[0])
    .concat(quickSort(arrRight));
  //return [...quickSort(arrLeft),arr[0],...quick(arrRight)]
}
```

常用的写法 O(nlogn)
最后一个数作为基准，从左边第一个开始和基准值比较，直到比基准值大，然后右边从倒数第二个开始和基准值比较，直到比基准值小，这是交换左右的这两个值，继续和基准值比较，。。。。。。
当左右的值重合的时候，如果比基准值小，左边继续往前，然后肯定比基准值大了，然后左和基准值接换位置。这样就变成了，基准值左边比他小，右边比他大。如果比基准值大，右边继续向前，这个值就肯定比基准值小，然后交换基准值和左值，这样同样也是基准值左边比他小，右边比他大。这样就实现了一次比较
然后用同样的方法分别比较左边和右边。。。。so easy

```javascript
function quickSort(arr) {
  function _quickSort(arr, start, end) {
    if (start >= end) return;
    let key = arr[end];
    let left = start,
      right = end - 1;
    while (left < right) {
      while (arr[left] < key && left < right) left++;
      while (arr[right] >= key && left < right) right--;
      [arr[left], arr[right]] = [arr[right], arr[left]];
    }
    if (arr[left] >= arr[end]) {
      [arr[left], arr[end]] = [arr[end], arr[left]];
    } else {
      // 如 [2, 1, 3, 4]
      left++;
    }
    _quickSort(arr, start, left - 1);
    _quickSort(arr, left + 1, end);
  }
  _quickSort(arr, 0, arr.length - 1);
  return arr;
}
```

## 希尔排序（O(nlogn)）

分成若干个子数组分别进行插入排序，继续分组排序，最后就所有一起排序
比如一开始分为四组，每组 2 个元素，第二轮分成俩组，每组 4 个元素，最后一次
一组排序

```javascript
//>>右移运算符，比如，1111（15）右移一位就是111（7）也就类似于除以2，向下取整
function shellSort(arr) {
  var temp;
  var len = arr.length;
  for (var gap = len >> 1; gap > 0; gap = gap >>= 1) {
    for (var i = gap; i < len; i++) {
      temp = arr[i];
      for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j];
      }
      arr[j + gap] = temp;
    }
    console.log(arr);
  }
}
```

## 归并排序 (O(nlogn))

数组分成俩个数组，分别在把俩数组分成更小的俩数组，直到数组的 length<2,不断比较俩数组的第一个元素，shift 出小的，放到 result 中

```javascript
function mergeSort(arr) {
  var merge = function(left, right) {
    var result = [];
    while (left.length && right.length) {
      result.push(left[0] <= right[0] ? left.shift() : right.shift());
    }
    return result.concat(left.concat(right));
  };
  if (arr.length < 2) return arr;
  var mid = arr.length >> 1;
  return merge(mergeSort(this.slice(0, mid)), mergeSort(this.slice(mid)));
}
```

## 计数排序（O(n+max)）

利用 hash 记录每个数字出现的次数，然后还原出来就完成了排序

```javascript
function countingSort(arr, maxValue) {
  var bucket = new Array(maxValue + 1),
    sortedIndex = 0;
  (arrLen = arr.length), (bucketLen = maxValue + 1);

  for (var i = 0; i < arrLen; i++) {
    if (!bucket[arr[i]]) {
      bucket[arr[i]] = 0;
    }
    bucket[arr[i]]++;
  }

  for (var j = 0; j < bucketLen; j++) {
    while (bucket[j] > 0) {
      arr[sortedIndex++] = j;
      bucket[j]--;
    }
  }

  return arr;
}
```

## 基数排序（O(n+max)）

基数：比如十进制的基数就是 10，所以准备 10 个桶（0-9），判断个位数属于哪个桶，放到对应的桶中，然后出桶（先进先出这样就是从小到大），然后按照 10 位数入桶出桶，依次百位，千位。。。。。。

```javascript
//LSD Radix Sort
var counter = [];
function radixSort(arr, maxDigit) {
  var mod = 10;
  var dev = 1;
  for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
    for (var j = 0; j < arr.length; j++) {
      var bucket = parseInt((arr[j] % mod) / dev);
      if (counter[bucket] == null) {
        counter[bucket] = [];
      }
      counter[bucket].push(arr[j]);
    }
    var pos = 0;
    for (var j = 0; j < counter.length; j++) {
      var value = null;
      if (counter[j] != null) {
        while ((value = counter[j].shift()) != null) {
          arr[pos++] = value;
        }
      }
    }
  }
  return arr;
}
```

## 桶排序（O(n+max)）

假设每个桶放 10 个数字（比如 1-9，10-19 这样的），判断数字应该属于哪个桶，对每个桶排序，然后出桶放到数组里就可以了

```javascript
function bucketSort(arr, bucketSize) {
  if (arr.length === 0) {
    return arr;
  }

  var i;
  var minValue = arr[0];
  var maxValue = arr[0];
  for (i = 1; i < arr.length; i++) {
    if (arr[i] < minValue) {
      minValue = arr[i]; // 输入数据的最小值
    } else if (arr[i] > maxValue) {
      maxValue = arr[i]; // 输入数据的最大值
    }
  }

  //桶的初始化
  var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5
  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
  var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;
  var buckets = new Array(bucketCount);
  for (i = 0; i < buckets.length; i++) {
    buckets[i] = [];
  }

  //利用映射函数将数据分配到各个桶中
  for (i = 0; i < arr.length; i++) {
    buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
  }

  arr.length = 0;
  for (i = 0; i < buckets.length; i++) {
    insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序
    for (var j = 0; j < buckets[i].length; j++) {
      arr.push(buckets[i][j]);
    }
  }

  return arr;
}
```

## 堆排序 （O(nlogn)）

利用最大堆让最大的数字到堆顶，思路越简单代码越难写。。。。

```javascript
var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) {
  // 建立大顶堆
  len = arr.length;
  for (var i = Math.floor(len / 2); i >= 0; i--) {
    heapify(arr, i);
  }
}

function heapify(arr, i) {
  // 堆调整
  var left = 2 * i + 1,
    right = 2 * i + 2,
    largest = i;

  if (left < len && arr[left] > arr[largest]) {
    largest = left;
  }

  if (right < len && arr[right] > arr[largest]) {
    largest = right;
  }

  if (largest != i) {
    swap(arr, i, largest);
    heapify(arr, largest);
  }
}

function swap(arr, i, j) {
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

function heapSort(arr) {
  buildMaxHeap(arr);

  for (var i = arr.length - 1; i > 0; i--) {
    swap(arr, 0, i);
    len--;
    heapify(arr, 0);
  }
  return arr;
}
```
