---
title: 排序算法
date: 2018-07-12 20:01:11
tags: [排序算法]
---

# 排序算法

## 冒泡排序（O(n^2)）

从第一个开始俩俩比较，大的放到后边，一轮之后，最大的数字就冒泡到了最后边。
然后开始第二轮比较。。。。。直到所有数字排序完成

代码实现

```javascript
function bubleSort(arr) {
  for (let i = 0; i < arr.length - 1 /*轮数*/; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
}
```

## 选择排序（O(n^2)）

假设第一个是最小的，依次和其他的比较，如果比第一个小，就交换位置。。。。。
最终就按照从大到小的顺序排好了
代码实现

```javascript
function sectionSort(arr) {
  for (let i = 0; i < arr.length - 1 /*轮数*/; i++) {
    let min = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[min] > arr[j]) {
        min = j;
      }
    }
    [arr[i], arr[min]] = [arr[min], arr[i]];
  }
}
```

## 插入排序（O(n^2)）

假设第一个元素排好了，从第二个元素开始，和已排序元素比较，放到排序好的合适的位置

代码实现

```javascript
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (arr[i] < arr[j]) {
        arr.splice(j, 0, arr[i]);
        arr.splice(i + 1, 1);
        break;
      }
    }
  }
}
```

## 快速排序

已第一个为基准，分成俩部分，左边比基数小，右边比基数大，最后把这三部分连接起来
左边和右边再分别进行快排

写起来简便，但不太好的写法

```javascript
function quickSort() {
  if (arr.length <= 1) {
    return arr;
  }
  let arrLeft = [];
  let arrRight = [];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] >= arr[0]) {
      arrRight.push(arr[i]);
    } else {
      arrLeft.push(arr[i]);
    }
  }
  return quickSort(arrLeft)
    .concat(arr[0])
    .concat(quickSort(arrRight));
  //return [...quickSort(arrLeft),arr[0],...quick(arrRight)]
}
```

常用的写法 O(nlogn)
最后一个数作为基准，从左边第一个开始和基准值比较，直到比基准值大，然后右边从倒数第二个开始和基准值比较，直到比基准值小，这是交换左右的这两个值，继续和基准值比较，。。。。。。
当左右的值重合的时候，如果比基准值小，左边继续往前，然后肯定比基准值大了，然后左和基准值接换位置。这样就变成了，基准值左边比他小，右边比他大。如果比基准值大，右边继续向前，这个值就肯定比基准值小，然后交换基准值和左值，这样同样也是基准值左边比他小，右边比他大。这样就实现了一次比较
然后用同样的方法分别比较左边和右边。。。。so easy

```javascript
function quickSort(arr) {
  function _quickSort(arr, start, end) {
    if (start >= end) return;
    let key = arr[end];
    let left = start,
      right = end - 1;
    while (left < right) {
      while (arr[left] < key && left < right) left++;
      while (arr[right] >= key && left < right) right--;
      [arr[left], arr[right]] = [arr[right], arr[left]];
    }
    if (arr[left] >= arr[end]) {
      [arr[left], arr[end]] = [arr[end], arr[left]];
    } else {
      // 如 [2, 1, 3, 4]
      left++;
    }
    _quickSort(arr, start, left - 1);
    _quickSort(arr, left + 1, end);
  }
  _quickSort(arr, 0, arr.length - 1);
  return arr;
}
```

## 希尔排序（O(nlogn)）

分成若干个子数组分别进行插入排序

## 归并排序 (O(nlogn))
